[{"categories":null,"contents":"This blog post will show how to deal with floating-point error in JavaScript by encoding all uint64\u0026rsquo;s, and int64\u0026rsquo;s as strings in JSON Marshaling.\nJavaScript has 53-bits of integer precision, this is a problem when trying to represent a 64-bit number. Ways of solving this in JavaScript is to use bigint or math.js, but when parsing JSON we can\u0026rsquo;t use this.\nWhen it goes wrong This is an example of how it can go wrong. Go encodes the JSON correctly, but when parsed by JavaScript the number does not match.\nGo Base data structure\ntype LargeId uint64 type Data struct { Id LargeId BigNum int64 }  Encode and Decode data\ndata := Data{Id: 12345678901234567892, BigNum: 12000000000002539} output, _ := json.Marshal(data) fmt.Println(\u0026quot;Data -\u0026gt; Json\u0026quot;, string(output)) input := string(output) output2 := Data{} json.Unmarshal([]byte(input), \u0026amp;output2) fmt.Printf(\u0026quot;Json -\u0026gt; Data %+v\\n\u0026quot;, output2) //Output Data -\u0026gt; Json {\u0026quot;Id\u0026quot;:12345678901234567892,\u0026quot;BigNum\u0026quot;:12000000000002539} Json -\u0026gt; Data {Id:12345678901234567892 BigNum:12000000000002539}  As you can see Go has no problem encoding and decoding the large integers. But let\u0026rsquo;s see what happens when JavaScript tries to decode the same integers.\nJavaScript var data = '{\u0026quot;Id\u0026quot;:12345678901234567892,\u0026quot;BigNum\u0026quot;:12000000000002539}' console.log(JSON.parse(data)) //Output Object {Id: 12345678901234567000, BigNum: 12000000000002540}  JavaScript ended up decoding the number, but its wrong. But if we check for equivalence in JavaScript it returns true.\n\u0026gt; 12000000000002539 === 12000000000002540 true  How to fix it The easiest way to fix this is to encode the int64 to a string, that way when parsed in JavaScript the number is represented correctly.\nBelow I have added json:\u0026quot;,string\u0026quot; tag to the end of every int64, this tells the encoding/json package to encode that field as a string instead of an integer.\nGo Base data structure with tags\ntype LargeId uint64 type Data struct { Id LargeId `json:\u0026quot;,string\u0026quot;` BigNum int64 `json:\u0026quot;,string\u0026quot;` }  Encode and Decode data\ndata := Data{Id: 12345678901234567892, BigNum: 12000000000002539} output, _ := json.Marshal(data) fmt.Println(\u0026quot;Data -\u0026gt; Json\u0026quot;, string(output)) input := string(output) output2 := Data{} json.Unmarshal([]byte(input), \u0026amp;output2) fmt.Printf(\u0026quot;Json -\u0026gt; Data %+v\\n\u0026quot;, output2) //Output Data -\u0026gt; Json {\u0026quot;Id\u0026quot;:\u0026quot;12345678901234567892\u0026quot;,\u0026quot;BigNum\u0026quot;:\u0026quot;12000000000002539\u0026quot;} Json -\u0026gt; Data {Id:12345678901234567892 BigNum:12000000000002539}  With the tag we can encode and decode the JSON and keep the int64 type in Go.\nJavaScript var data = '{\u0026quot;Id\u0026quot;:\u0026quot;12345678901234567892\u0026quot;,\u0026quot;BigNum\u0026quot;:\u0026quot;12000000000002539\u0026quot;}' console.log(JSON.parse(data)) //Output Object {Id: \u0026quot;12345678901234567892\u0026quot;, BigNum: \u0026quot;12000000000002539\u0026quot;}  Now the number is represented correctly in JavaScript. This is useful if you are using the number as an identifier, but makes it difficult to do arithmetic operations on the number.\n","permalink":"https://morgancreekmore.me/posts/floating-point-hell/","tags":null,"title":"Floating Point Hell"},{"categories":null,"contents":"This is a quick little blog post for how to install QEMU for ARM on Debian 7.0 (Wheezy).\nInstalling Toolchains Edit /etc/apt/sources.list and add\ndeb http://emdebian.org/debian/ stable main deb http://ftp.us.debian.org/debian/ squeeze main  The squeeze repo is for the package libgmp3c2 that is unavailable on wheezy.\nInstall the emdebian public key\napt-get install emdebian-archive-keyring apt-get update  Install ARM toolchains\napt-get install linux-libc-dev-armel-cross libc6-armel-cross libc6-dev-armel-cross binutils-arm-linux-gnueabi gcc-4.4-arm-linux-gnueabi g++-4.4-arm-linux-gnueabi  Installing QEMU Install QEMU\napt-get install qemu qemu-user-static  Optional: Install QEMU GUI\napt-get install aqemu  Hello ARM Time to test everything is working.\nhelloarm.s\n.text .globl _start _start: mov r0, #5 @ Load register r0 with the value 5 mov r1, #4 @ Load register r1 with the value 4 add r2, r1, r0 @ Add r0 and r1 and store in r2 stop: b stop @ Infinite loop to stop execution  Assemble, Link, Build\narm-linux-gnueabi-as -o helloarm.o helloarm.s arm-linux-gnueabi-ld -o helloarm.elf helloarm.o arm-linux-gnueabi-objcopy -O binary helloarm.elf helloarm.bin  Setup flash.bin\ndd if=/dev/zero of=flash.bin bs=4096 count=4096 dd if=helloarm.bin of=flash.bin bs=4096 conv=notrunc  Launch QEMU\nqemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null  There should now be a (qemu) prompt, type info registers and should see something like this\nR00=00000005 R01=00000004 R02=00000009 R03=00000000 R04=00000000 R05=00000000 R06=00000000 R07=00000000 R08=00000000 R09=00000000 R10=00000000 R11=00000000 R12=00000000 R13=00000000 R14=00000000 R15=0000000c PSR=400001d3 -Z-- A svc32  R02=00000009 Register 2 has the value 9 in it so everything is working.\nA more in-depth explanation of this helloarm program can be found here.\n","permalink":"https://morgancreekmore.me/posts/setup-qemu-for-arm-on-wheezy/","tags":null,"title":"Setup QEMU for ARM on Wheezy"}]